<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GeoExport Studio | Print A4 300DPI</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet Draw CSS & JS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <!-- OSMTogeojson -->
    <script src="https://unpkg.com/osmtogeojson@3.0.0-beta.5/osmtogeojson.js"></script>
    <!-- PDF Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg2pdf.js/2.2.3/svg2pdf.umd.min.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: 'Outfit', sans-serif;
            background: #ffffff;
            color: #0f172a;
            overflow: hidden;
        }
        h1, h2, h3, .font-serif { font-family: 'Playfair Display', serif; }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #e2e8f0; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #cbd5e1; }

        .glass {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-right: 1px solid rgba(0,0,0,0.05);
        }

        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #000;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Custom Selection Area Styling */
        .leaflet-draw-shape {
            background-color: rgba(255, 82, 82, 0.15) !important;
            border: 2px dashed #ff5252 !important;
            pointer-events: none;
        }
        
        /* Progress Bar */
        .progress-container {
            width: 100%;
            background-color: #e2e8f0;
            border-radius: 9999px;
            height: 8px;
            overflow: hidden;
            margin-top: 12px;
            display: none;
        }
        .progress-bar {
            height: 100%;
            background-color: #000;
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="app" class="flex h-screen w-screen">
        <!-- Sidebar -->
        <aside class="w-96 h-full glass flex flex-col shadow-2xl z-[1000] transition-all relative">
            <div class="p-8 border-b border-slate-100 bg-white">
                <div class="flex items-center gap-3 mb-6">
                    <div class="w-10 h-10 bg-black flex items-center justify-center rounded-xl shadow-lg">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6 text-white" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/></svg>
                    </div>
                    <div>
                        <h1 class="text-xl font-extrabold text-black leading-tight">Studio Print</h1>
                        <p class="text-[10px] text-slate-500 uppercase font-black tracking-widest">A4 Vertical • 300 DPI</p>
                    </div>
                </div>

                <!-- Search Bar -->
                <div class="relative group">
                    <input type="text" id="cityInput" placeholder="Escribe una ciudad..." 
                           class="w-full bg-slate-50 border border-slate-200 text-slate-800 text-sm font-semibold rounded-xl px-4 py-4 focus:outline-none focus:ring-2 focus:ring-black focus:border-transparent transition-all placeholder:text-slate-400" />
                    <button onclick="searchCity()" class="absolute right-2 top-2 bottom-2 bg-black text-white px-5 rounded-lg text-xs font-bold uppercase hover:bg-slate-800 transition-colors">Buscar</button>
                </div>
            </div>

            <div class="flex-1 overflow-y-auto p-8 space-y-8">
                <!-- Filters -->
                <section>
                    <h2 class="text-xs font-black text-slate-900 uppercase tracking-widest mb-4">Elementos</h2>
                    <div class="space-y-3">
                        <label class="flex items-center gap-3 p-3 bg-white border border-slate-200 rounded-xl cursor-pointer hover:border-black transition-all shadow-sm">
                            <input type="checkbox" id="checkStreets" checked class="w-5 h-5 rounded border-slate-300 text-black focus:ring-black" />
                            <span class="text-sm font-bold text-slate-700">Vías y Calles</span>
                        </label>
                        <label class="flex items-center gap-3 p-3 bg-white border border-slate-200 rounded-xl cursor-pointer hover:border-black transition-all shadow-sm">
                            <input type="checkbox" id="checkBuildings" checked class="w-5 h-5 rounded border-slate-300 text-black focus:ring-black" />
                            <span class="text-sm font-bold text-slate-700">Edificios</span>
                        </label>
                        <label class="flex items-center gap-3 p-3 bg-white border border-slate-200 rounded-xl cursor-pointer hover:border-black transition-all shadow-sm">
                            <input type="checkbox" id="checkWater" checked class="w-5 h-5 rounded border-slate-300 text-black focus:ring-black" />
                            <span class="text-sm font-bold text-slate-700">Agua y Ríos</span>
                        </label>
                        <label class="flex items-center gap-3 p-3 bg-white border border-slate-200 rounded-xl cursor-pointer hover:border-black transition-all shadow-sm">
                            <input type="checkbox" id="checkLabels" checked class="w-5 h-5 rounded border-slate-300 text-black focus:ring-black" />
                            <span class="text-sm font-bold text-slate-700">Nombres</span>
                        </label>
                    </div>
                </section>

                <!-- Selection Area -->
                <section>
                    <h2 class="text-xs font-black text-slate-900 uppercase tracking-widest mb-4">Zona a Enmarcar</h2>
                    <div class="grid grid-cols-2 gap-3">
                        <button onclick="activateDrawTool()" class="flex flex-col items-center justify-center gap-2 p-4 border-2 border-dashed border-slate-300 rounded-xl hover:border-red-400 hover:bg-red-50 transition-all group">
                            <svg class="w-6 h-6 text-slate-400 group-hover:text-red-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/></svg>
                            <span class="text-[10px] font-bold uppercase text-slate-500 group-hover:text-red-600">Dibujar Recorte</span>
                        </button>
                        <button onclick="clearSelection()" class="flex flex-col items-center justify-center gap-2 p-4 border-2 border-dashed border-slate-300 rounded-xl hover:border-black hover:bg-slate-100 transition-all group">
                            <svg class="w-6 h-6 text-slate-400 group-hover:text-black" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 18L18 6M6 6l12 12"/></svg>
                            <span class="text-[10px] font-bold uppercase text-slate-500 group-hover:text-black">Limpiar</span>
                        </button>
                    </div>
                    <p class="text-[10px] text-slate-400 mt-3 font-medium leading-tight">El área seleccionada se verá tenue y coloreada para diferenciarla del mapa.</p>
                </section>
            </div>

            <!-- Export Action -->
            <div class="p-8 border-t border-slate-100 bg-white z-10">
                <div id="exportContainer">
                    <button id="exportBtn" onclick="generatePDF()" class="w-full py-5 bg-black hover:bg-slate-800 text-white font-black rounded-2xl shadow-xl transition-all flex items-center justify-center gap-3 uppercase tracking-widest text-sm group">
                        <span id="btnText">Descargar PDF (A4)</span>
                        <div id="btnLoader" class="loader hidden w-4 h-4 border-2 border-white/30 border-t-white"></div>
                    </button>
                    <div class="progress-container" id="progressContainer">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                    <p id="statusText" class="text-[10px] text-center text-slate-400 mt-3 font-bold uppercase">Listo para exportar</p>
                </div>
            </div>
        </aside>

        <!-- Main Map Area -->
        <main class="relative flex-1 bg-slate-100">
            <div id="map" class="h-full w-full"></div>
            
            <!-- Status Overlay -->
            <div class="absolute top-6 right-6 z-[1001] pointer-events-none">
                <div class="bg-white/90 backdrop-blur px-4 py-2 rounded-full shadow-lg border border-slate-200 flex items-center gap-3">
                    <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                    <span class="text-[10px] font-bold uppercase tracking-widest text-slate-500">Motor 300 DPI</span>
                </div>
            </div>
            
            <!-- Loading Full Overlay -->
            <div id="loadingOverlay" class="absolute inset-0 bg-white/80 backdrop-blur-sm z-[2000] flex flex-col items-center justify-center hidden">
                <div class="loader mb-4 w-8 h-8"></div>
                <h3 class="text-lg font-serif font-bold text-slate-800">Procesando Mapa</h3>
                <p class="text-sm text-slate-500 font-medium mt-1" id="overlayStatus">Iniciando carga por bloques...</p>
            </div>
        </main>
    </div>

    <script>
        // --- CONFIG ---
        let map;
        let geojsonLayer;
        let drawnItems;
        let currentData = null; 
        let drawControl;

        // --- INIT ---
        window.onload = () => {
            initMap();
        };

        function initMap() {
            map = L.map('map', {
                zoomControl: false,
                attributionControl: false
            }).setView([40.4168, -3.7038], 14); 

            L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                maxZoom: 19,
            }).addTo(map);

            L.control.zoom({ position: 'bottomright' }).addTo(map);

            geojsonLayer = L.featureGroup().addTo(map);
            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);

            const customShapeOptions = {
                color: '#ff5252',
                weight: 2,
                fillColor: '#ff5252',
                fillOpacity: 0.15,
                dashArray: '5, 5',
            };

            drawControl = new L.Control.Draw({
                draw: {
                    polygon: false,
                    circle: false,
                    circlemarker: false,
                    marker: false,
                    polyline: false,
                    rectangle: {
                        shapeOptions: customShapeOptions
                    }
                },
                edit: {
                    featureGroup: drawnItems,
                    remove: true
                }
            });

            map.on(L.Draw.Event.CREATED, function (e) {
                const layer = e.layer;
                drawnItems.clearLayers(); 
                drawnItems.addLayer(layer);
                map.removeControl(drawControl); 
                layer.setStyle(customShapeOptions);
                const bounds = layer.getBounds();
                fetchData(bounds);
            });
        }

        // --- SEARCH CITY ---
        async function searchCity() {
            const query = document.getElementById('cityInput').value;
            if (!query) return;

            showLoading(true);
            try {
                const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`);
                const data = await res.json();
                
                if (data && data.length > 0) {
                    const { lat, lon, boundingbox } = data[0];
                    const bounds = [[boundingbox[0], boundingbox[3]], [boundingbox[1], boundingbox[2]]];

                    map.flyTo([lat, lon], 15, { duration: 1.5 });
                    await fetchData(bounds);
                } else {
                    alert("Ciudad no encontrada.");
                }
            } catch (err) {
                console.error(err);
                alert("Error al buscar ciudad.");
            } finally {
                showLoading(false);
            }
        }

        // --- FETCH OSM DATA (GRID STRATEGY) ---
        async function fetchData(bounds) {
            showLoading(true);
            drawnItems.clearLayers();
            updateStatus("Analizando área y dividiendo en bloques...", 0);
            
            const south = bounds.getSouth();
            const west = bounds.getWest();
            const north = bounds.getNorth();
            const east = bounds.getEast();
            
            // Grid Size: 0.015 degrees is approx 1.5km at this latitude. 
            // Good balance between API limit and request count.
            const gridSize = 0.015; 

            const lats = [];
            const lons = [];
            
            for(let lat = south; lat < north; lat += gridSize) lats.push(lat);
            for(let lon = west; lon < east; lon += gridSize) lons.push(lon);

            let allFeatures = [];
            let totalRequests = lats.length * lons.length;
            let completedRequests = 0;

            for (let i = 0; i < lats.length; i++) {
                for (let j = 0; j < lons.length; j++) {
                    const s = lats[i];
                    const w = lons[j];
                    const n = Math.min(s + gridSize, north);
                    const e = Math.min(w + gridSize, east);

                    // Overpass Query for a smaller cell
                    const query = `
                        [out:json][timeout:25];
                        (
                          way["highway"](${s},${w},${n},${e});
                          relation["highway"](${s},${w},${n},${e});
                          way["building"](${s},${w},${n},${e});
                          way["waterway"](${s},${w},${n},${e});
                          way["natural"="water"](${s},${w},${n},${e});
                        );
                        out geom;
                    `;
                    
                    try {
                        const res = await fetch('https://overpass-api.de/api/interpreter', {
                            method: 'POST',
                            body: query
                        });
                        const data = await res.json();
                        
                        // Convert and append features
                        if(data.elements && data.elements.length > 0) {
                            const geoJson = osmtogeojson(data);
                            // Simple filtering to remove tiny artifacts (noise)
                            const validFeatures = geoJson.features.filter(f => {
                                if (f.geometry.type === 'Point') return false;
                                return true;
                            });
                            allFeatures = allFeatures.concat(validFeatures);
                        }
                    } catch (err) {
                        console.warn("Chunk failed", err);
                    }

                    completedRequests++;
                    const percent = Math.round((completedRequests / totalRequests) * 50); // First 50% is fetching
                    updateStatus(`Descargando bloques de datos...`, percent);
                }
            }

            // Combine results
            currentData = {
                type: "FeatureCollection",
                features: allFeatures
            };

            updateStatus("Renderizando mapa...", 80);
            // Allow UI to breathe before heavy render
            setTimeout(() => {
                updateMapDisplay();
                showLoading(false);
                updateStatus("Mapa listo para editar", 100);
            }, 100);
        }

        function activateDrawTool() {
            map.addControl(drawControl);
            new L.Draw.Rectangle(map, drawControl.draw.rectangle).enable();
        }

        function clearSelection() {
            drawnItems.clearLayers();
            geojsonLayer.clearLayers();
            currentData = null;
            map.removeControl(drawControl);
        }

        function showLoading(show) {
            const el = document.getElementById('loadingOverlay');
            if(show) el.classList.remove('hidden');
            else el.classList.add('hidden');
        }

        function updateStatus(text, percent) {
            document.getElementById('statusText').textContent = text;
            document.getElementById('overlayStatus').textContent = text;
            
            const pContainer = document.getElementById('progressContainer');
            const pBar = document.getElementById('progressBar');
            
            pContainer.style.display = 'block';
            pBar.style.width = percent + '%';
        }

        function updateMapDisplay() {
            geojsonLayer.clearLayers();
            if (!currentData) return;

            const showStreets = document.getElementById('checkStreets').checked;
            const showBuildings = document.getElementById('checkBuildings').checked;
            const showWater = document.getElementById('checkWater').checked;
            const showLabels = document.getElementById('checkLabels').checked;

            L.geoJSON(currentData, {
                style: (feature) => {
                    const props = feature.properties || {};
                    if (props.building) return { color: '#000', weight: 0.5, fillOpacity: 0.1, fillColor: '#000' };
                    if (props.waterway || props.natural === 'water') return { color: '#3b82f6', weight: 2, fillOpacity: 0.4, fillColor: '#bfdbfe' };
                    if (props.highway) return { color: '#94a3b8', weight: 3 };
                    return { color: '#ccc', weight: 1 };
                },
                filter: (feature) => {
                    const props = feature.properties || {};
                    if (props.highway && !showStreets) return false;
                    if (props.building && !showBuildings) return false;
                    if ((props.waterway || props.natural === 'water') && !showWater) return false;
                    return true;
                },
                pointToLayer: (feature, latlng) => {
                    if (showLabels && feature.properties.name) return L.circleMarker(latlng, { radius: 0, opacity: 0 });
                    return null;
                },
                onEachFeature: (feature, layer) => {
                    if (feature.properties.name) layer.bindTooltip(feature.properties.name, {permanent: false, direction: 'top'});
                }
            }).addTo(geojsonLayer);
        }

        ['checkStreets', 'checkBuildings', 'checkWater', 'checkLabels'].forEach(id => {
            document.getElementById(id).addEventListener('change', updateMapDisplay);
        });

        // --- EXPORT LOGIC (A4 PDF HIGH QUALITY) ---
        async function generatePDF() {
            if (!currentData) {
                alert("Por favor, busca una ciudad o dibuja un área primero.");
                return;
            }

            const { jsPDF } = window.jspdf;
            const btnText = document.getElementById('btnText');
            const btnLoader = document.getElementById('btnLoader');
            
            btnText.textContent = "Generando PDF...";
            btnLoader.classList.remove('hidden');
            updateStatus("Preparando vectores de alta resolución...", 20);

            // 1. A4 Dimensions in points (1pt = 1/72 inch)
            // A4 is 210mm x 297mm -> approx 595.28pt x 841.89pt
            const pdfW = 595.28;
            const pdfH = 841.89;

            // 2. Determine Bounds
            let bounds;
            if (drawnItems.getLayers().length > 0) {
                bounds = drawnItems.getBounds();
            } else {
                bounds = map.getBounds();
            }

            // 3. Calculate Mercator Bounds
            const toWebMercator = (lat, lon) => {
                const x = (lon * 20037508.34) / 180;
                let y = Math.log(Math.tan(((90 + lat) * Math.PI) / 360)) / (Math.PI / 180);
                y = (y * 20037508.34) / 180;
                return { x, y };
            };

            const minM = toWebMercator(bounds.getSouth(), bounds.getWest());
            const maxM = toWebMercator(bounds.getNorth(), bounds.getEast());
            
            const mercW = maxM.x - minM.x;
            const mercH = maxM.y - minM.y;

            // 4. Calculate Scale for PDF (A4)
            const margin = 20; // pt
            const availableW = pdfW - (margin * 2);
            const availableH = pdfH - (margin * 2);

            const scaleX = availableW / mercW;
            const scaleY = availableH / mercH;
            const scale = Math.min(scaleX, scaleY);

            const mapW = mercW * scale;
            const mapH = mercH * scale;

            const offsetX = (pdfW - mapW) / 2;
            const offsetY = (pdfH - mapH) / 2;

            const project = (lat, lon) => {
                const merc = toWebMercator(lat, lon);
                const px = (merc.x - minM.x) * scale;
                const py = mapH - (merc.y - minM.y) * scale; 
                return { x: px.toFixed(3), y: py.toFixed(3) };
            };

            const showStreets = document.getElementById('checkStreets').checked;
            const showBuildings = document.getElementById('checkBuildings').checked;
            const showWater = document.getElementById('checkWater').checked;
            const showLabels = document.getElementById('checkLabels').checked;

            const features = currentData.features;
            let svgContent = '';
            let svgDefs = '';
            let pathIdCounter = 0;

            const processLine = (line) => line.map((c, i) => (i === 0 ? 'M' : 'L') + `${project(c[1], c[0]).x},${project(c[1], c[0]).y}`).join(' ');

            for (const feature of features) {
                if (!feature.geometry) continue;
                const props = feature.properties || {};
                const type = feature.geometry.type;
                const coords = feature.geometry.coordinates;
                let d = '';

                if (props.highway && !showStreets) continue;
                if (props.building && !showBuildings) continue;
                if ((props.waterway || props.natural === 'water') && !showWater) continue;

                let style = "";
                if (props.highway) {
                    style = `stroke:#1a1a1a; stroke-width:1.2; fill:none; stroke-linecap:round; stroke-linejoin:round;`; 
                } else if (props.building) {
                    style = `fill:#f1f5f9; stroke:#475569; stroke-width:0.3; fill-opacity:1;`;
                } else if (props.waterway || props.natural === 'water') {
                    style = `fill:#e0f2fe; stroke:#0369a1; stroke-width:0.5; fill-opacity:1;`;
                } else continue;

                if (type === 'LineString') d = processLine(coords);
                else if (type === 'MultiLineString') d = coords.map(processLine).join(' ');
                else if (type === 'Polygon') d = coords.map(ring => processLine(ring) + ' Z').join(' ');
                else if (type === 'MultiPolygon') d = coords.map(poly => poly.map(ring => processLine(ring) + ' Z').join(' ')).join(' ');

                if (d) svgContent += `<path d="${d}" style="${style}" />\n`;

                if (showLabels && props.name && (props.highway || props.waterway) && (type === 'LineString' || type === 'MultiLineString')) {
                    let pathD = type === 'MultiLineString' ? processLine(coords[0]) : d;
                    const textPathId = `tp_${pathIdCounter++}`;
                    svgDefs += `<path id="${textPathId}" d="${pathD}" fill="none" stroke="none" />`;
                    svgContent += `<text style="font-family: Arial, sans-serif; font-size: 6px; font-weight: bold; fill: #334155;"><textPath href="#${textPathId}" startOffset="50%" text-anchor="middle">${props.name}</textPath></text>\n`;
                }
            }

            updateStatus("Generando PDF de alta fidelidad...", 70);

            // Create temporary SVG for svg2pdf
            const svgString = `<svg width="${pdfW}" height="${pdfH}" viewBox="0 0 ${pdfW} ${pdfH}" xmlns="http://www.w3.org/2000/svg">
                <defs>${svgDefs}</defs>
                <rect width="100%" height="100%" fill="#FFFFFF" />
                <g transform="translate(${offsetX.toFixed(3)}, ${offsetY.toFixed(3)})">
                    <g transform="scale(1, -1) translate(0, -${mapH.toFixed(3)})">
                        ${svgContent}
                    </g>
                </g>
            </svg>`;

            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');
            const svgElement = svgDoc.documentElement;

            const pdf = new jsPDF({
                orientation: 'portrait',
                unit: 'pt',
                format: 'a4'
            });

            try {
                await pdf.svg(svgElement, {
                    x: 0,
                    y: 0,
                    width: pdfW,
                    height: pdfH
                });

                pdf.save(`mapa_pro_a4_${Date.now()}.pdf`);
                
                btnText.textContent = "Descargar PDF (A4)";
                btnLoader.classList.add('hidden');
                updateStatus("PDF generado con éxito", 100);
            } catch (err) {
                console.error("Error generating PDF:", err);
                alert("Hubo un error al generar el PDF. Revisa la consola.");
                btnText.textContent = "Error";
                btnLoader.classList.add('hidden');
            }
        }
    </script>
</body>
</html>